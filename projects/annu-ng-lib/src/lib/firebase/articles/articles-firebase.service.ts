import { Injectable } from '@angular/core';
import { initializeApp } from 'firebase/app';

import {
  getFirestore,
  collection,
  getDocs,
  getDoc,
  addDoc,
  doc,
  setDoc,
  deleteDoc,
  writeBatch,
  WriteBatch,
  Timestamp,
  query,
  where,
  QueryConstraint,
  orderBy,
  startAfter,
  startAt,
  limit,
} from 'firebase/firestore';
import { FirebaseConfig } from '../firebase.interface';

import { Category, Article } from '../../components/cms';
import { categories, articles } from './articles-firebase.seed';
import { UtilsService } from '../../services';
import { LibConfig } from '../../annu-ng-lib.interface';

const FIREBASE_DOCS = {
  CATEGORIES: 'categories',
  ARTICLES: 'articles'
}

@Injectable({
  providedIn: 'root'
})
export class ArticlesFirebaseService {

  constructor(private libConfig: LibConfig, private utilsSvc: UtilsService) {
    // initialize firebase
    const firebaseApp = initializeApp(this.libConfig.firebase);
    console.log('firebase App initialized - ', firebaseApp.name);
  }


  /**
   * This is a static property that return the Error type, that can be used to identify all errors generated from this service.
   * ErrorService and ErrorComponet can use this type to identify source of error.
   *
   * @public
   * @static
   * @readonly
   * @type {string}
   */
  public static get errorType(): string {
    return 'ArticlesFirebaseService';
  }

  /**
   * Adds a new category for the logged in user, and optionally publishes(live) it too.
   *
   * @public
   * @async
   * @param {Category} newCategory
   * @param {string} userId
   * @param {boolean} [publish=false]
   * @returns {Promise<Category>} Return the added category with a new autogenerated category id.
   */
  public async addCategory(newCategory: Category, userId: string, publish = false): Promise<Category> {
    const currentDate = this.utilsSvc.currentDate;
    const category = { ...newCategory, userId, created: currentDate, updated: currentDate, isLive: publish };

    try {
      const db = getFirestore();
      const categoriesRef = collection(db, FIREBASE_DOCS.CATEGORIES);

      const categoryRef = await addDoc(categoriesRef, category);
      category.id = categoryRef.id;

      return category;
    } catch (error: any) {
      return null;
    }
  }

  /**
   * Updates a category, for the logged in user.
   *
   * @public
   * @async
   * @param {Category} pCategory
   * @param {string} userId
   * @returns {Promise<Category>} returns the updated category.
   */
  public async setCategory(pCategory: Category, userId: string): Promise<Category> {
    const currentDate = this.utilsSvc.currentDate;
    const category = { ...pCategory, userId, updated: currentDate };
    try {
      const db = getFirestore();
      const categoriesRef = collection(db, FIREBASE_DOCS.CATEGORIES);
      const categoryRef = doc(categoriesRef, category.id);

      await setDoc(categoryRef, category);

      return category;
    } catch (error: any) {
      return null;
    }
  }


  /**
   * Description placeholder
   * @date 9/2/2022 - 6:31:45 pm
   *
   * @public
   * @async
   * @param {Category} category
   * @returns {Promise<boolean>}
   */
  public async deleteCategory(category: Category): Promise<boolean> {
    try {
      const db = getFirestore();
      const categoriesRef = collection(db, FIREBASE_DOCS.CATEGORIES);
      const categoryRef = doc(categoriesRef, category.id);

      await deleteDoc(categoryRef);

      return true;
    } catch (error: any) {
      return false;
    }
  }

  /**
   * Reads a category based on a category id.
   *
   * @public
   * @async
   * @param {string} id
   * @returns {Promise<Category>}
   */
  public async getCategory(id: string): Promise<Category> {
    try {
      const db = getFirestore();
      const querySnapshot = await getDoc(doc(db, FIREBASE_DOCS.CATEGORIES, id));
      if (!querySnapshot.exists()) {
        return null;
      }

      const category: Category = {
        id: querySnapshot.id,
        ...querySnapshot.data(),
      }

      return category;
    } catch (error: any) {
      return null;
    }
  }

  public async getCategories(userId: string, startPage = 0, pageSize = 5): Promise<Array<Category>> {
    try {
      const db = getFirestore();
      const categoriesRef = collection(db, FIREBASE_DOCS.CATEGORIES);
      const queryRef = query(categoriesRef,
        orderBy('updated'),
        where('userId', '==', userId),
        where('isLive', '==', true),
        startAt(startPage),
        limit(pageSize));

      const querySnapshot = await getDocs(queryRef);
      const categories: Array<Category> = [];
      querySnapshot.forEach((doc) => {
        categories.push({
          id: doc.id,
          ...doc.data(),
        });
      });

      return categories;
    } catch (error: any) {
      return [];
    }
  }



  public async addArticle(article: Article): Promise<Article> {
    try {
      const db = getFirestore();
      const articlesRef = collection(db, FIREBASE_DOCS.ARTICLES);

      const articleRef = await addDoc(articlesRef, article);
      article.id = articleRef.id;

      return article;
    } catch (error: any) {
      return null;
    }
  }

  public async setArticle(article: Article): Promise<Article> {
    try {
      const db = getFirestore();
      const articlesRef = collection(db, FIREBASE_DOCS.ARTICLES);
      const articleRef = doc(articlesRef, article.id);

      await setDoc(articleRef, article);

      return article;
    } catch (error: any) {
      return null;
    }
  }

  public async deleteArticle(article: Article): Promise<boolean> {
    try {
      const db = getFirestore();
      const articlesRef = collection(db, FIREBASE_DOCS.ARTICLES);
      const articleRef = doc(articlesRef, article.id);

      await deleteDoc(articleRef);

      return true;
    } catch (error: any) {
      return false;
    }
  }

  public async getArticle(id: string): Promise<Article> {
    try {
      const db = getFirestore();
      const querySnapshot = await getDoc(doc(db, FIREBASE_DOCS.ARTICLES, id));
      if (!querySnapshot.exists()) {
        return null;
      }

      const article: Article = {
        id: querySnapshot.id,
        ...querySnapshot.data(),
      }

      return article;
    } catch (error: any) {
      return null;
    }
  }


  /**
   * getArticles() method fetches all articles from the firestore, irrespective of published or not.
   *
   * @public
   * @async
   * @returns {Promise<Array<Article>>}
   */
  public async getArticles(): Promise<Array<Article>> {
    try {
      const db = getFirestore();
      const articlesRef = collection(db, FIREBASE_DOCS.ARTICLES);
      const querySnapshot = await getDocs(articlesRef);
      const articles: Array<Article> = [];
      querySnapshot.forEach((doc) => {
        articles.push({
          id: doc.id,
          ...doc.data(),
        });
      });

      return articles;
    } catch (error: any) {
      return [];
    }
  }

  /**
   * getLiveArticles() fetches articles that have been published.
   */
  public async getLiveArticles(): Promise<Array<Article>> {
    try {
      const db = getFirestore();
      const articlesRef = collection(db, FIREBASE_DOCS.ARTICLES);
      const queryRef = query(articlesRef, where('isLive', '==', true));
      const querySnapshot = await getDocs(queryRef);
      const articles: Array<Article> = [];
      querySnapshot.forEach((doc) => {
        articles.push({
          id: doc.id,
          ...doc.data(),
        });
      });

      return articles;
    } catch (error: any) {
      return [];
    }
  }

  /**
   * seedDatabase() - populates the database with initial data.
   * This method needs to be run only once.
   */
  public async seedDatabase(): Promise<string> {
    const db = getFirestore();
    const writeBatchRef: WriteBatch = writeBatch(db);
    const categoriesRef = collection(db, FIREBASE_DOCS.CATEGORIES);
    const articlesRef = collection(db, FIREBASE_DOCS.ARTICLES);

    categories.forEach(c => writeBatchRef.set(doc(categoriesRef), { ...c, created: this.utilsSvc.currentDate, updated: this.utilsSvc.currentDate }));
    articles.forEach(a => writeBatchRef.set(doc(articlesRef), { ...a, created: this.utilsSvc.currentDate, metaInfo: { ...a.metaInfo, 'article:published_time': this.utilsSvc.currentDate } }));

    try {
      await writeBatchRef.commit();
      return 'SUCCESSFUL Seeding Articles firestore';
    } catch (error: any) {
      return 'Failed Seeding Articles firestore';
    }
  }
}
