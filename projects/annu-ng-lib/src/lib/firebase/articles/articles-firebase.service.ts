import { Injectable } from '@angular/core';

import {
  getFirestore,
  collection,
  getDocs,
  getDoc,
  doc,
  setDoc,
  deleteDoc,
  writeBatch,
  WriteBatch,
  query,
  where,
  orderBy,
  startAfter,
  limit,
  endBefore,
  limitToLast,
  QueryConstraint,
} from 'firebase/firestore';

import { Category, Article } from '../../components/cms';
import { ArticlesFirebaseSeedService } from './articles-firebase-seed.service';
import { UtilsService } from '../../services/utils/utils.service';
import { AuthFirebaseService } from '../auth';
import { QueryConfig } from '../firebase.interface';
import { ImageFireStoreService } from '../image-storage/image-fire-store.service';
import { ARTICLES_COLLECTIONS } from './articles-firebase.constants';
import { CommonFirebaseService } from '../common-firebase';

/**
 * Description placeholder
 * @date 19/2/2022 - 3:48:18 pm
 *
 * @export
 * @class ArticlesFirebaseService
 * @typedef {ArticlesFirebaseService}
 */
@Injectable({
  providedIn: 'root'
})
export class ArticlesFirebaseService {

  constructor(private utilsSvc: UtilsService,
    private commonFirebaseSvc: CommonFirebaseService,
    private fireAuthSvc: AuthFirebaseService,
    private imageFireStoreService: ImageFireStoreService,
    private articlesFireSeedSvc: ArticlesFirebaseSeedService) { }

  /**
   * Adds a new category for the logged in user.
   *
   * @public
   * @async
   * @param {Category} newCategory
   * @param {string} userId
   * @returns {Promise<Category>} Return the added category with a new autogenerated category id.
   */
  public async addCategory(newCategory: Category): Promise<Category> {
    return await this.setCategory(newCategory);
  }

  /**
   * Updates a category, for the logged in user.
   *
   * @public
   * @async
   * @param {Category} pCategory
   * @param {string} userId
   * @returns {Promise<Category>} returns the updated category.
   */
  public async setCategory(pCategory: Category): Promise<Category> {
    const currentDate = this.utilsSvc.currentDate;
    const category = { ...pCategory, updated: currentDate };
    if (!pCategory.created) category.created = currentDate;
    if (!pCategory.userId) category.userId = this.fireAuthSvc.getCurrentUserId();
    delete category.id;

    try {
      if (category.image && category.image.imageData) {
        const imgSrc = `${pCategory.id}/${pCategory.id}.jpeg`;
        const imageFileInfo = await this.imageFireStoreService.uploadImage(imgSrc, category.image.imageData);
        if (imageFileInfo.downloadUrl) {
          category.image.src = imageFileInfo.downloadUrl;
        } else {
          category.image.src = await this.imageFireStoreService.getImageUrl(imgSrc);
        }
        delete category.image.imageData;
      }

      const db = getFirestore();
      const categoriesRef = collection(db, ARTICLES_COLLECTIONS.CATEGORIES);
      const categoryRef = doc(categoriesRef, pCategory.id);

      await setDoc(categoryRef, category);

      return { ...category, id: pCategory.id };
    } catch (error: any) {
      throw error;
    }
  }


  /**
   * Description placeholder
   * @date 9/2/2022 - 6:31:45 pm
   *
   * @public
   * @async
   * @param {Category} category
   * @returns {Promise<boolean>}
   */
  public async deleteCategory(category: Category): Promise<boolean> {
    try {
      const db = getFirestore();
      const categoriesRef = collection(db, ARTICLES_COLLECTIONS.CATEGORIES);
      const categoryRef = doc(categoriesRef, category.id);

      await deleteDoc(categoryRef);

      return true;
    } catch (error: any) {
      throw error;
    }
  }

  /**
   * Reads a category based on a category id.
   *
   * @public
   * @async
   * @param {string} id
   * @returns {Promise<Category>}
   */
  public async getCategoryById(id: string): Promise<Category> {
    try {
      const db = getFirestore(this.commonFirebaseSvc.initOrGetFirebaseApp());
      const querySnapshot = await getDoc(doc(db, ARTICLES_COLLECTIONS.CATEGORIES, id));
      if (!querySnapshot.exists()) {
        throw new Error(`Category with id- ${id} does not exist`);
      }

      const category: Category = {
        id: querySnapshot.id,
        ...querySnapshot.data(),
      }

      return category;
    } catch (error: any) {
      throw error;
    }
  }
  /**
   * Reads Categories based on where conditions, orderby, and pagination.</br>
   * <strong>userId:</strong> filter by user id</br>
   * <strong>name:</strong> filter by name or array of names</br>
   * <strong>id:</strong> filter by id or array of ids</br>
   * <strong>orderField:</strong> name of the orderBy field, this has to be same field that is used for startPage, if pagination is used.</br>
   * <strong>isDesc:</strong>  if true, orderBy field is sorted desc or asc order.</br>
   * <strong>isForwardDir:</strong> if true, pagination will be forward else backward direction</br>
   * <strong>startPage:</strong> startPage should have the value of the orderBy field of the first or last record of previously fetched records.</br>
   * <strong>pageSize:</strong> if pageSize is les that equal to 0, then no pagination will be done</br>
   * <strong>isLive:</strong> if null, ignores filtering based on isLive. Otherwise filters documents that are published or unbulished based on true/false value.</br>
   * @date 19/2/2022 - 9:41:44 pm
   *
   * @public
   * @async
   * @param {QueryConfig} queryConfig filter using a query config
   * @returns {Promise<Array<Category>>}
   */
  public async getCategories(queryConfig: QueryConfig): Promise<Array<Category>> {
    try {
      const db = getFirestore();
      const categoriesRef = collection(db, ARTICLES_COLLECTIONS.CATEGORIES);
      const queryArgs = this.buildQuery({ ...queryConfig } as QueryConfig);

      const queryRef = query(categoriesRef, ...queryArgs);

      const querySnapshot = await getDocs(queryRef);
      const categories: Array<Category> = [];
      querySnapshot.forEach((doc) => {
        categories.push({
          id: doc.id,
          ...doc.data() as any,
        });
      });

      return categories;
    } catch (error: any) {
      throw error;
    }
  }



  /**
   * Adds an article, and optionally publishes it.
   * @date 19/2/2022 - 10:11:11 pm
   *
   * @public
   * @async
   * @param {Article} newArticle
   * @returns {Promise<Article>}
   */
  public async addArticle(newArticle: Article): Promise<Article> {
    return await this.setArticle(newArticle);
  }


  /**
   * Updates an article
   * @date 19/2/2022 - 10:13:21 pm
   *
   * @public
   * @async
   * @param {Article} pArticle
   * @returns {Promise<Article>}
   */
  public async setArticle(pArticle: Article): Promise<Article> {
    const currentDate = this.utilsSvc.currentDate;
    const article = { ...pArticle, updated: currentDate };
    if (!pArticle.created) article.created = currentDate;
    if (!pArticle.userId) article.userId = this.fireAuthSvc.getCurrentUserId();
    delete article.id;
    delete article.categoriesGroup;

    try {
      const db = getFirestore();
      const articlesRef = collection(db, ARTICLES_COLLECTIONS.ARTICLES);
      const articleRef = doc(articlesRef, pArticle.id);

      await setDoc(articleRef, article);

      return { ...article, id: pArticle.id };
    } catch (error: any) {
      throw error;
    }
  }


  /**
   * Deletes an article, Only user with admin rights can delete an article.
   * @date 19/2/2022 - 10:17:14 pm
   *
   * @public
   * @async
   * @param {Article} article
   * @returns {Promise<boolean>}
   */
  public async deleteArticle(article: Article): Promise<boolean> {
    try {
      const db = getFirestore();
      const articlesRef = collection(db, ARTICLES_COLLECTIONS.ARTICLES);
      const articleRef = doc(articlesRef, article.id);

      await deleteDoc(articleRef);

      return true;
    } catch (error: any) {
      throw error;
    }
  }


  /**
   * Reads a article based on a article id.
   * Add name of collectiongroup, where data population is needed, eg. categories.
   * @date 20/2/2022 - 5:05:44 pm
   *
   * @public
   * @async
   * @param {string} id
   * @param {Array<string>} [groupCollections=[]]
   * @returns {Promise<Article>}
   */
  public async getArticleById(id: string, groupCollections: Array<string> = []): Promise<Article> {

    try {
      const db = getFirestore();
      const articleRef = doc(db, ARTICLES_COLLECTIONS.ARTICLES, id);
      const querySnapshot = await getDoc(articleRef);
      if (!querySnapshot.exists()) {
        throw new Error(`Article with id- ${id} does not exist`);
      }

      const article: Article = {
        id: querySnapshot.id,
        ...querySnapshot.data(),
      }

      if (groupCollections && groupCollections.length) {
        // Add conditions for other Collection Groups, if any
        if (groupCollections.includes('categories')) {
          const qConfig: QueryConfig = {
            id: article.categories
          };
          const cats = await this.getCategories(qConfig);
          article.categoriesGroup = cats;
        }
      }

      return article;
    } catch (error: any) {
      throw error;
    }
  }


  /**
   * Reads Articles based on where conditions, orderby, and pagination.</br>
   * This method can be used for various combination of queries, articles by userid, id/s, name/s, artcileCatgoryId/s, sorting, pagination etc.</br>
   * <strong>userId:</strong> filter by user id</br>
   * <strong>name:</strong> filter by name or array of names</br>
   * <strong>id:</strong> filter by id or array of ids</br>
   * <strong>articleCategoryId:</strong> filter by articleCategoryId or array of articleCategoryIds</br>
   * <strong>orderField:</strong> name of the orderBy field, this has to be same field that is used for startPage, if pagination is used.</br>
   * <strong>isDesc:</strong>  if true, orderBy field is sorted desc or asc order.</br>
   * <strong>isForwardDir:</strong> if true, pagination will be forward else backward direction</br>
   * <strong>startPage:</strong> startPage should have the value of the orderBy field of the first or last record of previously fetched records.</br>
   * <strong>pageSize:</strong> if pageSize is les that equal to 0, then no pagination will be done</br>
   * <strong>isLive:</strong> if null, ignores filtering based on isLive. Otherwise filters documents that are published or unbulished based on true/false value.</br>
   * @date 19/2/2022 - 9:41:44 pm
   *
   * @public
   * @async
   * @param {QueryConfig} queryConfig filter by queryConfig.
   * @returns {Promise<Array<Article>>}
   */
  public async getArticles(queryConfig: QueryConfig): Promise<Array<Article>> {
    try {
      const db = getFirestore();
      const articlesRef = collection(db, ARTICLES_COLLECTIONS.ARTICLES);
      const queryArgs: Array<QueryConstraint> = this.buildQuery({ ...queryConfig } as QueryConfig);

      const queryRef = query(articlesRef, ...queryArgs);

      const querySnapshot = await getDocs(queryRef);
      const articles: Array<Article> = [];
      querySnapshot.forEach((doc) => {
        articles.push({
          id: doc.id,
          ...doc.data() as any,
        });
      });

      return articles;
    } catch (error: any) {
      throw error;
    }
  }

  /**
   * seedDatabase() - populates the database with initial data.
   * This method needs to be run only once.
   * @date 19/2/2022 - 10:27:30 pm
   *
   * @public
   * @async
   * @param {number} [seedRecordCount=6]
   * @returns {Promise<string>}
   */
  public async seedDatabase(categoriesCount: number = 5,
    featuredCatgoriesCount: number = 3,
    categoryArticlesCount: number = 5): Promise<string> {
    const db = getFirestore();
    const writeBatchRef: WriteBatch = writeBatch(db);
    const categoriesRef = collection(db, ARTICLES_COLLECTIONS.CATEGORIES);
    const articlesRef = collection(db, ARTICLES_COLLECTIONS.ARTICLES);

    const articlesDatabaseSeed = await this.articlesFireSeedSvc.generateArticlesDatabaseSeed(this.fireAuthSvc.getCurrentUserId(),
      categoriesCount, featuredCatgoriesCount, categoryArticlesCount);

    articlesDatabaseSeed.categories.forEach(c => {
      const categoryId = c.id;
      delete c.id;
      writeBatchRef.set(doc(categoriesRef, categoryId), { ...c });
    });

    articlesDatabaseSeed.articles.forEach(a => {
      const articleId = a.id;
      delete a.id;
      writeBatchRef.set(doc(articlesRef, articleId), { ...a });
    });

    try {
      await writeBatchRef.commit();
      return 'SUCCESSFUL Seeding Articles firestore';
    } catch (error: any) {
      throw error;
    }
  }

  /**
   * Builds a read query, with where conditions, orderby, and pagination attributes.
   * @date 19/2/2022 - 10:27:58 pm
   *
   * @public
   * @param {QueryConfig} queryConfig
   * @returns {Array<QueryConstraint>}
   */
  public buildQuery(queryConfig: QueryConfig): Array<QueryConstraint> {
    const queryArgs: Array<QueryConstraint> = [];

    const { userId, id, articleCategoryId, isLive, orderField, isDesc, isForwardDir, startPage, pageSize } = queryConfig;

    // if userid is given, then fetches categories of that user only, else will fetch all categories
    if (userId) {
      queryArgs.push(where('userId', '==', userId));
    }

    if (id) {
      const opr = id instanceof Array ? 'in' : '==';
      queryArgs.push(where('__name__', opr, id));
    }

    if (articleCategoryId) {
      const opr = articleCategoryId instanceof Array ? 'array-contains-any' : 'array-contains';
      queryArgs.push(where('categories', opr, articleCategoryId));
    }
    // add condition only when either true or false. if null, then not add condition, and fetch irrespective of isLive
    if (isLive === true || isLive === false) {
      queryArgs.push(where('isLive', '==', isLive));
    }

    if (orderField) {
      queryArgs.push(orderBy(orderField, isDesc === true ? 'desc' : 'asc'));
    }

    if (startPage) {
      if (isForwardDir !== false) {
        queryArgs.push(startAfter(startPage));
      } else {
        queryArgs.push(endBefore(startPage));
      }
    }

    if (pageSize > 0) {
      if (isForwardDir !== false) {
        queryArgs.push(limit(pageSize));
      } else {
        queryArgs.push(limitToLast(pageSize));
      }
    }

    return queryArgs;
  }
}

//TODO: Add Group Queries.
