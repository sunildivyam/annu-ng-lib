import { Injectable } from '@angular/core';

import {
  getFirestore,
  collection,
  getDocs,
  getDoc,
  addDoc,
  doc,
  setDoc,
  deleteDoc,
  writeBatch,
  WriteBatch,
  Timestamp,
  query,
  where,
  QueryConstraint,
  orderBy,
  startAfter,
  startAt,
  limit,
  CollectionReference,
  DocumentData,
  FieldPath,
  OrderByDirection,
  endBefore,
  limitToLast,
} from 'firebase/firestore';

import { Category, Article } from '../../components/cms';
import { getSeedsCategories, getSeedsArticles } from './articles-firebase.seed';
import { UtilsService } from '../../services';
import { LibConfig } from '../../annu-ng-lib.interface';
import { AuthFirebaseService } from '../auth';
import { User } from 'firebase/auth';

const FIREBASE_DOCS = {
  CATEGORIES: 'categories',
  ARTICLES: 'articles'
}

export interface QueryConfig {
  userId?: string;
  name?: string;
  orderField?: string;
  isDesc?: boolean;
  isNextPages?: boolean;
  startPage: any;
  pageSize?: number;
  isLive?: boolean | null;
};


/**
 * Description placeholder
 * @date 19/2/2022 - 3:48:18 pm
 *
 * @export
 * @class ArticlesFirebaseService
 * @typedef {ArticlesFirebaseService}
 */
@Injectable({
  providedIn: 'root'
})
export class ArticlesFirebaseService {

  constructor(private libConfig: LibConfig, private utilsSvc: UtilsService, private fireAuthSvc: AuthFirebaseService) { }

  /**
   * Adds a new category for the logged in user, and optionally publishes(live) it too.
   *
   * @public
   * @async
   * @param {Category} newCategory
   * @param {string} userId
   * @param {boolean} [publish=false]
   * @returns {Promise<Category>} Return the added category with a new autogenerated category id.
   */
  public async addCategory(newCategory: Category, publish = false): Promise<Category> {
    const currentDate = this.utilsSvc.currentDate;
    const category = {
      ...newCategory,
      userId: this.fireAuthSvc.getCurrentUserId(),
      created: currentDate,
      updated: currentDate,
      isLive: !!publish
    };
    if (category.id) {
      throw new Error(`This Category has an id - ${category.id}, so this Category may already exist, please check and try again.`);
    }
    try {
      const db = getFirestore();
      const categoriesRef = collection(db, FIREBASE_DOCS.CATEGORIES);

      const categoryRef = await addDoc(categoriesRef, category);
      category.id = categoryRef.id;

      return category;
    } catch (error: any) {
      throw error;
    }
  }

  /**
   * Updates a category, for the logged in user.
   *
   * @public
   * @async
   * @param {Category} pCategory
   * @param {string} userId
   * @returns {Promise<Category>} returns the updated category.
   */
  public async setCategory(pCategory: Category): Promise<Category> {
    const currentDate = this.utilsSvc.currentDate;
    const category = { ...pCategory, updated: currentDate };
    delete category.id;

    try {
      const db = getFirestore();
      const categoriesRef = collection(db, FIREBASE_DOCS.CATEGORIES);
      const categoryRef = doc(categoriesRef, category.id);

      await setDoc(categoryRef, category);

      return category;
    } catch (error: any) {
      throw error;
    }
  }


  /**
   * Description placeholder
   * @date 9/2/2022 - 6:31:45 pm
   *
   * @public
   * @async
   * @param {Category} category
   * @returns {Promise<boolean>}
   */
  public async deleteCategory(category: Category): Promise<boolean> {
    try {
      const db = getFirestore();
      const categoriesRef = collection(db, FIREBASE_DOCS.CATEGORIES);
      const categoryRef = doc(categoriesRef, category.id);

      await deleteDoc(categoryRef);

      return true;
    } catch (error: any) {
      throw error;
    }
  }

  /**
   * Reads a category based on a category id.
   *
   * @public
   * @async
   * @param {string} id
   * @returns {Promise<Category>}
   */
  public async getCategoryById(id: string): Promise<Category> {
    try {
      const db = getFirestore();
      const querySnapshot = await getDoc(doc(db, FIREBASE_DOCS.CATEGORIES, id));
      if (!querySnapshot.exists()) {
        throw new Error(`Category with id- ${id} does not exist`);
      }

      const category: Category = {
        id: querySnapshot.id,
        ...querySnapshot.data(),
      }

      return category;
    } catch (error: any) {
      throw error;
    }
  }

  /**
   * Reads Categories based on where conditions, orderby, and pagination.</br>
   * <strong>userId:</strong> filter by user id</br>
   * <strong>orderField:</strong> name of the orderBy field, this has to be same field that is used for startPage, if pagination is used.</br>
   * <strong>isDesc:</strong>  if true, orderBy field is sorted desc or asc order.</br>
   * <strong>isNextPages:</strong> if true, pagination will be forward else backward direction</br>
   * <strong>startPage:</strong> startPage should have the value of the orderBy field of the first or last record of previously fetched records.</br>
   * <strong>pageSize:</strong> if pageSize is les that equal to 0, then no pagination will be done</br>
   * <strong>isLive:</strong> if null, ignores filtering based on isLive. Otherwise filters documents that are published or unbulished based on true/false value.</br>
   * @date 19/2/2022 - 9:41:44 pm
   *
   * @public
   * @async
   * @param {string} userId filter by user id
   * @param {string} orderField name of the orderBy field, this has to be same field that is used for startPage, if pagination is used.
   * @param {string} isDesc  if true, orderBy field is sorted desc or asc order.
   * @param {boolean} [isNextPages=true]  if true, pagination will be forward else backward direction
   * @param {*} [startPage='']  startPage should have the value of the orderBy field of the first or last record of previously fetched records.
   * @param {number} [pageSize=5] if pageSize is les that equal to 0, then no pagination will be done
   * @param {(boolean | null)} [isLive=true]  if null, ignores filtering based on isLive. Otherwise filters documents that are published or unbulished based on true/false value.
   * @returns {Promise<Array<Category>>}
   */
  public async getCategories(userId: string, name: string, isLive: boolean | null = true, orderField: string, isDesc: boolean, isNextPages: boolean = true, startPage: any = '', pageSize: number = 5): Promise<Array<Category>> {
    try {
      const db = getFirestore();
      const categoriesRef = collection(db, FIREBASE_DOCS.CATEGORIES);
      const queryArgs = this.buildQuery(categoriesRef, { userId, name, isLive, orderField, isDesc, isNextPages, startPage, pageSize } as QueryConfig);

      const queryRef = query.apply(this, [...queryArgs]);

      const querySnapshot = await getDocs(queryRef);
      const categories: Array<Category> = [];
      querySnapshot.forEach((doc) => {
        categories.push({
          id: doc.id,
          ...doc.data() as any,
        });
      });

      return categories;
    } catch (error: any) {
      throw error;
    }
  }



  /**
   * Adds an article, and optionally publishes it.
   * @date 19/2/2022 - 10:11:11 pm
   *
   * @public
   * @async
   * @param {Article} newArticle
   * @param {boolean} [publish=false]
   * @returns {Promise<Article>}
   */
  public async addArticle(newArticle: Article, publish = false): Promise<Article> {
    const currentDate = this.utilsSvc.currentDate;
    const article = {
      ...newArticle,
      userId: this.fireAuthSvc.getCurrentUserId(),
      created: currentDate,
      updated: currentDate,
      isLive: !!publish
    };
    if (article.id) {
      throw new Error(`This Article has an id - ${article.id}, so this Article may already exist, please check and try again.`);
    }
    try {
      const db = getFirestore();
      const articlesRef = collection(db, FIREBASE_DOCS.ARTICLES);

      const articleRef = await addDoc(articlesRef, article);
      article.id = articleRef.id;

      return article;
    } catch (error: any) {
      throw error;
    }
  }


  /**
   * Updates an article
   * @date 19/2/2022 - 10:13:21 pm
   *
   * @public
   * @async
   * @param {Article} pArticle
   * @returns {Promise<Article>}
   */
  public async setArticle(pArticle: Article): Promise<Article> {
    const currentDate = this.utilsSvc.currentDate;
    const article = { ...pArticle, updated: currentDate };
    delete article.id;

    try {
      const db = getFirestore();
      const articlesRef = collection(db, FIREBASE_DOCS.ARTICLES);
      const articleRef = doc(articlesRef, article.id);

      await setDoc(articleRef, article);

      return article;
    } catch (error: any) {
      throw error;
    }
  }


  /**
   * Deletes an article, Only user with admin rights can delete an article.
   * @date 19/2/2022 - 10:17:14 pm
   *
   * @public
   * @async
   * @param {Article} article
   * @returns {Promise<boolean>}
   */
  public async deleteArticle(article: Article): Promise<boolean> {
    try {
      const db = getFirestore();
      const articlesRef = collection(db, FIREBASE_DOCS.ARTICLES);
      const articleRef = doc(articlesRef, article.id);

      await deleteDoc(articleRef);

      return true;
    } catch (error: any) {
      throw error;
    }
  }

  /**
   * Reads a article based on a article id.
   *
   * @public
   * @async
   * @param {string} id
   * @returns {Promise<Article>}
   */
  public async getArticleById(id: string): Promise<Article> {
    try {
      const db = getFirestore();
      const querySnapshot = await getDoc(doc(db, FIREBASE_DOCS.ARTICLES, id));
      if (!querySnapshot.exists()) {
        throw new Error(`Article with id- ${id} does not exist`);
      }

      const article: Article = {
        id: querySnapshot.id,
        ...querySnapshot.data(),
      }

      return article;
    } catch (error: any) {
      throw error;
    }
  }


  /**
   * Reads Categories based on where conditions, orderby, and pagination.</br>
   * <strong>userId:</strong> filter by user id</br>
   * <strong>orderField:</strong> name of the orderBy field, this has to be same field that is used for startPage, if pagination is used.</br>
   * <strong>isDesc:</strong>  if true, orderBy field is sorted desc or asc order.</br>
   * <strong>isNextPages:</strong> if true, pagination will be forward else backward direction</br>
   * <strong>startPage:</strong> startPage should have the value of the orderBy field of the first or last record of previously fetched records.</br>
   * <strong>pageSize:</strong> if pageSize is les that equal to 0, then no pagination will be done</br>
   * <strong>isLive:</strong> if null, ignores filtering based on isLive. Otherwise filters documents that are published or unbulished based on true/false value.</br>
   * @date 19/2/2022 - 9:41:44 pm
   *
   * @public
   * @async
   * @param {string} userId filter by user id
   * @param {string} orderField name of the orderBy field, this has to be same field that is used for startPage, if pagination is used.
   * @param {string} isDesc  if true, orderBy field is sorted desc or asc order.
   * @param {boolean} [isNextPages=true]  if true, pagination will be forward else backward direction
   * @param {*} [startPage='']  startPage should have the value of the orderBy field of the first or last record of previously fetched records.
   * @param {number} [pageSize=5] if pageSize is les that equal to 0, then no pagination will be done
   * @param {(boolean | null)} [isLive=true]  if null, ignores filtering based on isLive. Otherwise filters documents that are published or unbulished based on true/false value.
   * @returns {Promise<Array<Article>>}
   */
  public async getArticles(userId: string, name: string, isLive: boolean | null = true, orderField: string, isDesc: boolean, isNextPages: boolean = true, startPage: any = '', pageSize: number = 5): Promise<Array<Article>> {
    try {
      const db = getFirestore();
      const articlesRef = collection(db, FIREBASE_DOCS.ARTICLES);
      const queryArgs = this.buildQuery(articlesRef, { userId, name, isLive, orderField, isDesc, isNextPages, startPage, pageSize } as QueryConfig);

      const queryRef = query.apply(this, [...queryArgs]);

      const querySnapshot = await getDocs(queryRef);
      const articles: Array<Article> = [];
      querySnapshot.forEach((doc) => {
        articles.push({
          id: doc.id,
          ...doc.data() as any,
        });
      });

      return articles;
    } catch (error: any) {
      throw error;
    }
  }


  /**
   * seedDatabase() - populates the database with initial data.
   * This method needs to be run only once.
   * @date 19/2/2022 - 10:27:30 pm
   *
   * @public
   * @async
   * @param {number} [seedRecordCount=6]
   * @returns {Promise<string>}
   */
  public async seedDatabase(seedRecordCount: number = 6): Promise<string> {
    const db = getFirestore();
    const writeBatchRef: WriteBatch = writeBatch(db);
    const categoriesRef = collection(db, FIREBASE_DOCS.CATEGORIES);
    const articlesRef = collection(db, FIREBASE_DOCS.ARTICLES);

    getSeedsCategories(seedRecordCount).forEach(c => writeBatchRef.set(doc(categoriesRef), {
      ...c,
      created: this.utilsSvc.currentDate,
      userId: this.fireAuthSvc.getCurrentUserId(),
      updated: this.utilsSvc.currentDate
    }));
    getSeedsArticles(seedRecordCount).forEach(a => writeBatchRef.set(doc(articlesRef), {
      ...a,
      created: this.utilsSvc.currentDate,
      userId: this.fireAuthSvc.getCurrentUserId(),
      metaInfo: { ...a.metaInfo, 'article:published_time': this.utilsSvc.currentDate }
    }));

    try {
      await writeBatchRef.commit();
      return 'SUCCESSFUL Seeding Articles firestore';
    } catch (error: any) {
      throw error;
    }
  }

  /**
   * Builds a read query, with where conditions, orderby, and pagination attributes.
   * @date 19/2/2022 - 10:27:58 pm
   *
   * @public
   * @param {CollectionReference<DocumentData>} documentsRef
   * @param {QueryConfig} queryConfig
   * @returns {Array<any>}
   */
  public buildQuery(documentsRef: CollectionReference<DocumentData>, queryConfig: QueryConfig): Array<any> {
    const queryArgs: Array<any> = [documentsRef];

    const { userId, name, isLive, orderField, isDesc, isNextPages, startPage, pageSize } = queryConfig;

    // if userid is given, then fetches categories of that user only, else will fetch all categories
    if (userId) {
      queryArgs.push(where('userId', '==', userId));
    }

    if (name) {
      queryArgs.push(where('name', '==', name));
    }

    // add condition only when either true or false. if null, then not add condition, and fetch irrespective of isLive
    if (isLive === true || isLive === false) {
      queryArgs.push(where('isLive', '==', isLive));
    }

    if (orderField) {
      queryArgs.push(orderBy(orderField, isDesc ? 'desc' : 'asc'));
    }

    if (orderField && pageSize >= 1) {
      if (isNextPages) {
        if (startPage) {
          queryArgs.push(startAfter(startPage));
          queryArgs.push(limit(pageSize));
        }
      } else {
        if (startPage) {
          queryArgs.push(endBefore(startPage));
          queryArgs.push(limitToLast(pageSize));
        }
      }
    }

    return queryArgs;
  }
}
