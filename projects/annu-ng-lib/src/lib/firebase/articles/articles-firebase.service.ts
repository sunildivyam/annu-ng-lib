import { Injectable } from '@angular/core';

import {
  getFirestore,
  collection,
  getDocs,
  getDoc,
  addDoc,
  doc,
  setDoc,
  deleteDoc,
  writeBatch,
  WriteBatch,
  Timestamp,
  query,
  where,
  QueryConstraint,
  orderBy,
  startAfter,
  startAt,
  limit,
} from 'firebase/firestore';

import { Category, Article } from '../../components/cms';
import { getSeedsCategories, getSeedsArticles } from './articles-firebase.seed';
import { UtilsService } from '../../services';
import { LibConfig } from '../../annu-ng-lib.interface';
import { AuthFirebaseService } from '../auth';
import { User } from 'firebase/auth';

const FIREBASE_DOCS = {
  CATEGORIES: 'categories',
  ARTICLES: 'articles'
}

@Injectable({
  providedIn: 'root'
})
export class ArticlesFirebaseService {

  constructor(private libConfig: LibConfig, private utilsSvc: UtilsService, private fireAuthSvc: AuthFirebaseService) { }


  /**
   * This is a static property that return the Error type, that can be used to identify all errors generated from this service.
   * ErrorService and ErrorComponet can use this type to identify source of error.
   *
   * @public
   * @static
   * @readonly
   * @type {string}
   */
  public static get errorType(): string {
    return 'ArticlesFirebaseService';
  }

  /**
   * Adds a new category for the logged in user, and optionally publishes(live) it too.
   *
   * @public
   * @async
   * @param {Category} newCategory
   * @param {string} userId
   * @param {boolean} [publish=false]
   * @returns {Promise<Category>} Return the added category with a new autogenerated category id.
   */
  public async addCategory(newCategory: Category, publish = false): Promise<Category> {
    const currentDate = this.utilsSvc.currentDate;
    const category = {
      ...newCategory,
      userId: this.fireAuthSvc.getCurrentUserId(),
      created: currentDate,
      updated: currentDate,
      isLive: !!publish
    };
    if (category.id) {
      throw new Error(`This Category has an id - ${category.id}, so this Category may already exist, please check and try again.`);
    }
    try {
      const db = getFirestore();
      const categoriesRef = collection(db, FIREBASE_DOCS.CATEGORIES);

      const categoryRef = await addDoc(categoriesRef, category);
      category.id = categoryRef.id;

      return category;
    } catch (error: any) {
      throw error;
    }
  }

  /**
   * Updates a category, for the logged in user.
   *
   * @public
   * @async
   * @param {Category} pCategory
   * @param {string} userId
   * @returns {Promise<Category>} returns the updated category.
   */
  public async setCategory(pCategory: Category): Promise<Category> {
    const currentDate = this.utilsSvc.currentDate;
    const category = { ...pCategory, updated: currentDate };
    delete category.id;

    try {
      const db = getFirestore();
      const categoriesRef = collection(db, FIREBASE_DOCS.CATEGORIES);
      const categoryRef = doc(categoriesRef, category.id);

      await setDoc(categoryRef, category);

      return category;
    } catch (error: any) {
      throw error;
    }
  }


  /**
   * Description placeholder
   * @date 9/2/2022 - 6:31:45 pm
   *
   * @public
   * @async
   * @param {Category} category
   * @returns {Promise<boolean>}
   */
  public async deleteCategory(category: Category): Promise<boolean> {
    try {
      const db = getFirestore();
      const categoriesRef = collection(db, FIREBASE_DOCS.CATEGORIES);
      const categoryRef = doc(categoriesRef, category.id);

      await deleteDoc(categoryRef);

      return true;
    } catch (error: any) {
      throw error;
    }
  }

  /**
   * Reads a category based on a category id.
   *
   * @public
   * @async
   * @param {string} id
   * @returns {Promise<Category>}
   */
  public async getCategoryById(id: string): Promise<Category> {
    try {
      const db = getFirestore();
      const querySnapshot = await getDoc(doc(db, FIREBASE_DOCS.CATEGORIES, id));
      if (!querySnapshot.exists()) {
        throw new Error(`Category with id- ${id} does not exist`);
      }

      const category: Category = {
        id: querySnapshot.id,
        ...querySnapshot.data(),
      }

      return category;
    } catch (error: any) {
      throw error;
    }
  }

  /**
   * Reads a category based on a category name.
   *
   * @public
   * @async
   * @param {string} name
   * @returns {Promise<Category>}
   */
  public async getCategoryByName(name: string): Promise<Category> {
    try {
      const db = getFirestore();
      const querySnapshot = await getDoc(doc(db, FIREBASE_DOCS.CATEGORIES, name));
      if (!querySnapshot.exists()) {
        throw new Error(`Category with name- ${name} does not exist`);
      }

      const category: Category = {
        id: querySnapshot.id,
        ...querySnapshot.data(),
      }

      return category;
    } catch (error: any) {
      throw error;
    }
  }


  public async getCategories(userId: string, startPage = 0, pageSize = 5, isLive: boolean | null = true): Promise<Array<Category>> {
    try {
      const db = getFirestore();
      const categoriesRef = collection(db, FIREBASE_DOCS.CATEGORIES);
      const queryArgs = [categoriesRef, orderBy('name')];

      // if userid is given, then fetches categories of that user only, else will fetch all categories
      if (userId) {
        queryArgs.push(where('userId', '==', userId));
      }

      // add condition only when either true or false. if null, then not add condition, and fetch irrespective of isLive
      if (isLive === true || isLive === false) {
        queryArgs.push(where('isLive', '==', isLive));
      }

      if (startPage >=0 && pageSize >= 1) {
        queryArgs.push(startAt(startPage));
        queryArgs.push(limit(pageSize));
      }

      const queryRef =  query.apply(this, [...queryArgs]);

      const querySnapshot = await getDocs(queryRef);
      const categories: Array<Category> = [];
      querySnapshot.forEach((doc) => {
        categories.push({
          id: doc.id,
          ...doc.data() as any,
        });
      });

      return categories;
    } catch (error: any) {
      throw error;
    }
  }



  public async addArticle(article: Article): Promise<Article> {
    try {
      const db = getFirestore();
      const articlesRef = collection(db, FIREBASE_DOCS.ARTICLES);

      const articleRef = await addDoc(articlesRef, article);
      article.id = articleRef.id;

      return article;
    } catch (error: any) {
      throw error;
    }
  }

  public async setArticle(article: Article): Promise<Article> {
    try {
      const db = getFirestore();
      const articlesRef = collection(db, FIREBASE_DOCS.ARTICLES);
      const articleRef = doc(articlesRef, article.id);

      await setDoc(articleRef, article);

      return article;
    } catch (error: any) {
      throw error;
    }
  }

  public async deleteArticle(article: Article): Promise<boolean> {
    try {
      const db = getFirestore();
      const articlesRef = collection(db, FIREBASE_DOCS.ARTICLES);
      const articleRef = doc(articlesRef, article.id);

      await deleteDoc(articleRef);

      return true;
    } catch (error: any) {
      throw error;
    }
  }

  public async getArticle(id: string): Promise<Article> {
    try {
      const db = getFirestore();
      const querySnapshot = await getDoc(doc(db, FIREBASE_DOCS.ARTICLES, id));
      if (!querySnapshot.exists()) {
        throw new Error('Article does not exist.');
      }

      const article: Article = {
        id: querySnapshot.id,
        ...querySnapshot.data(),
      }

      return article;
    } catch (error: any) {
      throw error;
    }
  }


  /**
   * getArticles() method fetches all articles from the firestore, irrespective of published or not.
   *
   * @public
   * @async
   * @returns {Promise<Array<Article>>}
   */
  public async getArticles(): Promise<Array<Article>> {
    try {
      const db = getFirestore();
      const articlesRef = collection(db, FIREBASE_DOCS.ARTICLES);
      const querySnapshot = await getDocs(articlesRef);
      const articles: Array<Article> = [];
      querySnapshot.forEach((doc) => {
        articles.push({
          id: doc.id,
          ...doc.data(),
        });
      });

      return articles;
    } catch (error: any) {
      throw error;
    }
  }

  /**
   * getLiveArticles() fetches articles that have been published.
   */
  public async getLiveArticles(): Promise<Array<Article>> {
    try {
      const db = getFirestore();
      const articlesRef = collection(db, FIREBASE_DOCS.ARTICLES);
      const queryRef = query(articlesRef, where('isLive', '==', true));
      const querySnapshot = await getDocs(queryRef);
      const articles: Array<Article> = [];
      querySnapshot.forEach((doc) => {
        articles.push({
          id: doc.id,
          ...doc.data(),
        });
      });

      return articles;
    } catch (error: any) {
      throw error;
    }
  }

  /**
   * seedDatabase() - populates the database with initial data.
   * This method needs to be run only once.
   */
  public async seedDatabase(): Promise<string> {
    const db = getFirestore();
    const writeBatchRef: WriteBatch = writeBatch(db);
    const categoriesRef = collection(db, FIREBASE_DOCS.CATEGORIES);
    const articlesRef = collection(db, FIREBASE_DOCS.ARTICLES);
    const seedRecordCount = 6;

    getSeedsCategories(seedRecordCount).forEach(c => writeBatchRef.set(doc(categoriesRef), {
      ...c,
      created: this.utilsSvc.currentDate,
      userId: this.fireAuthSvc.getCurrentUserId(),
      updated: this.utilsSvc.currentDate
    }));
    getSeedsArticles(seedRecordCount).forEach(a => writeBatchRef.set(doc(articlesRef), {
      ...a,
      created: this.utilsSvc.currentDate,
      userId: this.fireAuthSvc.getCurrentUserId(),
      metaInfo: { ...a.metaInfo, 'article:published_time': this.utilsSvc.currentDate }
    }));

    try {
      await writeBatchRef.commit();
      return 'SUCCESSFUL Seeding Articles firestore';
    } catch (error: any) {
      throw error;
    }
  }

}
